

local push_in_process = false
local trigger_flag = false
local go_list = { puck={}, spinner={} }


function init(self)
	--msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
	msg.post( '.', 'acquire_input_focus' )

	math.randomseed( os.time() )

	-- make sure gravity is off
	physics.set_gravity( vmath.vector3(0,0,0) )

	-- factory.create( '/spinfactory#factory', vmath.vector3(512,256,0.1), nil, { imageNum=-1 }, 0.75 )

	self.touch_obj = nil
	push_in_process = false
	trigger_flag = false

end


function push_complete( self, handle, time_elapsed )
	print( 'push complete', self.last_touch )
	push_in_process = false
	
	-- un-select the touched-puck-obj
	go.set( self.main_puck.url, 'isSelected', 0 )

	if( trigger_flag ) then
		print( 'detected crossing ... good!' )
		msg.post( '/hud', 'thru_score' )
	else
		print( 'puck did not cross ... bad!' )
		local orig_pos = {}
		for i,p in pairs(self.orig_pos) do
			table.insert( orig_pos, p )
		end
		msg.post( '/hud', 'puck_missed', {orig_pos=orig_pos} )
	end

end

function apply_push( self, force )
	-- lock out other actions
	push_in_process = true
	-- reset the trigger flag (to detect if a crossing happened)
	trigger_flag = false

	-- check that puck went through the other two
	-- : and mark the touched-puck to see if it scores a goal
	self.main_puck = self.touch_obj
	self.alt_pucks = {}
	local pos = {}
	for key,obj in pairs(go_list.puck) do
		if( obj == self.main_puck ) then
			go.set( obj.url, 'isSelected', 1 )
		else
			go.set( obj.url, 'isSelected', 0 )
			table.insert( self.alt_pucks, obj )
		end
		pos[obj.path] = go.get_position(obj.url)
	end

	local pos = go.get_position( self.main_puck.path )
	local my_url = msg.url( self.main_puck.socket, self.main_puck.path, 'collisionobject' )
	msg.post( my_url, "apply_force", { force=force, position=pos } )

	-- start the slow-down timer on each puck
	for i,p in pairs(go_list.puck) do
		-- this resumes sliding ('resume_motion') and triggers the push/action
		msg.post( p.path, 'slow_motion' )
	end
	-- TODO: this 4.0s delay must match what's in the puck slow-down script
	timer.delay( 4.0, false, push_complete )
end

function on_message( self, message_id, message, sender )
	--print( 'main-recvd message ',message_id,' from ', sender, message.url )
	if( message_id == hash('check_in' ) ) then
		print( 'main: check_in', sender )
		go_list[ message.type ][ message.path ] = message
		-- pprint( pucklist )
	elseif( message_id == hash('check_out' ) ) then
		print( 'main: check_out', sender )
		local idx = nil
		if( go_list[ message.type ][ message.path ] == nil ) then
			print( 'bad value for checkout' )
			-- pprint( message )
			-- print( 'list' )
			-- pprint( go_list )
			-- print( 'list[puck]' )
			-- pprint( go_list[message.type] )
			-- pprint( go_list[message.type][message.path] )
			-- for k,v in pairs(go_list[message.type]) do
			-- 	if( v.path == message.path ) then
			-- 		print( 'found', k,v,message.path )
			-- 	end
			-- end
		else
			go_list[ message.type ][ message.path ] = nil
		end

		push_in_process = false

	elseif( message_id == hash('new_pucks') ) then
		print( 'new_pucks' )
		-- need to restart from last position
		-- : delete the old pucks
		for i,p in pairs(go_list.puck) do
			go.delete( p.path )
		end
		-- : create new ones
		for key,val in pairs(message.orig_pos) do
			local id = factory.create( '/puckfactory#factory', val, nil, { imageNum=message.counter+1 }, 1.0 )
		end
		
	elseif( message_id == hash('collision_response' ) ) then
		print( 'main: collision_response from', sender )
		-- pprint( message )

	elseif( message_id == hash('all_stop') ) then
		for i,p in pairs(pucklist) do
			msg.post( p.path, 'halt_motion' )
		end
	end
end

function update( self, dt )
	if( push_in_process ) then
		-- re-orient the trigger-line
		local pos = {}
		for i,p in pairs(go_list.puck) do
			pos[p.path] = go.get_position(p.url)
		end
		local p0 = self.orig_pos[ self.last_touch.path ]
		local p1 = pos[ self.main_puck.path ]
		local p2 = pos[ self.alt_pucks[1].path ]
		local p3 = pos[ self.alt_pucks[2].path ]

		-- following: https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect
		if( trigger_flag == false ) then
			local s1 = vmath.vector3( p1.x-p0.x, p1.y-p0.y, 0 )
			local s2 = vmath.vector3( p3.x-p2.x, p3.y-p2.y, 0 )
			local s = (-s1.y * (p0.x - p2.x) + s1.x * (p0.y - p2.y)) / (-s2.x * s1.y + s1.x * s2.y)
			local t = ( s2.x * (p0.y - p2.y) - s2.y * (p0.x - p2.x)) / (-s2.x * s1.y + s1.x * s2.y)
			if( (s>=0) and (s<=1) and (t>=0) and (t<=1) ) then
				-- Collision detected
				local i_x = p0.x + (t * s1.x)
				local i_y = p0.y + (t * s1.y)
				print( 'puck went through' )
				trigger_flag = true

				go.set_position( vmath.vector3(i_x,i_y,0.1), '/pfx#pfx' )
				particlefx.play( '/pfx#pfx' )
			end
		end

		-- debugging: show the line-gfx obj on-screen
		--msg.post("@render:", "draw_line", { start_point=p2, end_point=p3, color = vmath.vector4(0,0,0,1) } )
		if( false ) then
			local pmid = ( p2 + p3 ) / 2
			pmid.z = 1  -- put it on top for debugging
			--print( 'pmid', pmid )
			local delta = vmath.vector3( p3.x-p2.x, p3.y-p2.y, 0 )
			local scl = vmath.length( delta ) / 134
			delta = vmath.normalize( delta )
			local qt = vmath.quat_from_to( vmath.vector3(1,0,0), delta )
			go.set_position( pmid, '/line' )
			go.set_rotation( qt, '/line' )
			go.set_scale( scl, '/line' )
		end

	end
end

--
-- handle input
--
local function is_inside( obj, x, y )
	local my_url = msg.url( obj.socket, obj.path, 'sprite' )
	local my_size = go.get( my_url, 'size' )
	local my_scale = go.get( obj.path, 'scale' )
	local my_pos  = go.get( obj.path, 'position' )
	local my_x1 = my_pos.x - my_scale.x*my_size.x*0.50
	local my_y1 = my_pos.y - my_scale.y*my_size.y*0.50
	local my_x2 = my_pos.x + my_scale.x*my_size.x*0.50
	local my_y2 = my_pos.y + my_scale.y*my_size.y*0.50
	local rtn = false
	if( (x>=my_x1) and (x<=my_x2) and (y>=my_y1) and (y<=my_y2) ) then
		rtn = true
	end
	return rtn
end

function on_input( self, action_id, action )
	local rtn = false
	if( action_id == hash('touch') ) then
		if( not push_in_process ) then
			if( action.pressed ) then
				for key,obj in pairs(go_list.puck) do
					if( is_inside(obj,action.x,action.y) ) then
						self.touch_obj = obj
						self.xyz0 = go.get_position( obj.path )
						
						self.orig_pos = {}
						for i,p in pairs(go_list.puck) do
							self.orig_pos[p.path] = go.get_position( p.path )
						end
						rtn = true
					end
				end
			elseif( action.released ) then
				if( self.touch_obj ~= nil ) then
					local vec = vmath.vector3( self.xyz0.x-action.x, self.xyz0.y-action.y, 0 )
					local power = vmath.length_sqr( vec )
					vec = vmath.normalize( vec )
					--print( 'power', power )
					--apply_push( self.touch_obj, 0.10*power*vec )
					apply_push( self, 0.10*power*vec )
					self.last_touch = self.touch_obj
					self.touch_obj = nil
					self.xyz0 = nil
					rtn = true
				end
			else
				-- should be a touch-drag operation
				if( self.touch_obj ~= nil ) then
					local xyz0 = vmath.vector3(self.xyz0)
					local xyz1 = vmath.vector3(action.x,action.y,0.1)
					msg.post("@render:", "draw_line", { start_point=xyz0, end_point=xyz1, color = vmath.vector4(1,0,0,1) } )
					xyz0.y = xyz0.y + 1
					xyz1.y = xyz1.y + 1
					msg.post("@render:", "draw_line", { start_point=xyz0, end_point=xyz1, color = vmath.vector4(1,0,0,1) } )
					xyz0.y = xyz0.y - 2
					xyz1.y = xyz1.y - 2
					msg.post("@render:", "draw_line", { start_point=xyz0, end_point=xyz1, color = vmath.vector4(1,0,0,1) } )
					xyz0.y = xyz0.y + 1  -- reset back to 0
					xyz1.y = xyz1.y + 1  -- reset back to 0
					xyz0.x = xyz0.x + 1
					xyz1.x = xyz1.x + 1
					msg.post("@render:", "draw_line", { start_point=xyz0, end_point=xyz1, color = vmath.vector4(1,0,0,1) } )
					xyz0.x = xyz0.x - 2
					xyz1.x = xyz1.x - 2
					msg.post("@render:", "draw_line", { start_point=xyz0, end_point=xyz1, color = vmath.vector4(1,0,0,1) } )
					rtn = true
				end
			end
		end
	end
	return rtn
end
